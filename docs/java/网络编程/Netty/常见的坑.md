
## 未释放ByteBuf
- 坑：未调用release()导致堆外内存泄漏
- 解决：使用ReferenceCountUtil.release()或try-finally块

## 未处理半包/粘包
- 粘包：TCP 是面向流的协议，发送方可能将多个消息合并发送，或者接收方一次性接收到多个消息，导致消息边界模糊。例如，客户端发送 "Hello" 和 "World"，服务器可能收到 "HelloWorld"。

- 半包：接收方可能只收到消息的一部分，例如，客户端发送 "HelloWorld"，服务器可能先收到 "Hel"，随后收到 "loWorld"。

问题：直接读取ByteBuf导致消息不完整
可以采用内置的FixedLengthFrameDecoder（固定长度协议）、LengthFieldBasedFrameDecoder（变长字段协议）、DelimiterBasedFrameDecoder（分隔符）、LineBasedFrameDecoder（换行符）解码器解决。



## 心跳未配置
- 坑：长连接无心跳导致假死
- 解决：添加IdleStateHandler
 
## 客户端频繁断开导致资源泄漏

1、未正确释放ByteBuf（堆外内存泄漏）
```java
ByteBuf buffer = ctx.alloc().buffer(); // 分配内存
// 未调用 buffer.release()，导致泄漏
```
2、Channel未关闭或未清理Pipeline

客户端断开时，若未调用channel.close()或未移除自定义ChannelHandler，可能导致：
- 线程池资源未释放。
- 内存中的Channel对象堆积
```java
@Override
public void channelInactive(ChannelHandlerContext ctx) {
    ctx.channel().close(); // 关闭Channel
    cleanupResources();    // 自定义清理逻辑
}
```
3、心跳机制缺失
未配置心跳检测，无法及时感知断开连接，导致资源滞留
```java
//添加心跳机制
pipeline.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));
pipeline.addLast(new HeartbeatHandler()); // 自定义心跳处理
```
4、线程池或EventLoop未正确关闭
频繁创建/销毁EventLoopGroup会导致线程泄漏
```java
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}));
```

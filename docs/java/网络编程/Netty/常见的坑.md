
## 未释放ByteBuf
- 坑：未调用release()导致堆外内存泄漏
- 解决：使用ReferenceCountUtil.release()或try-finally块

## 未处理半包/粘包
- 坑：直接读取ByteBuf导致消息不完整
- 解决：添加LengthFieldBasedFrameDecoder

## 心跳未配置
- 坑：长连接无心跳导致假死
- 解决：添加IdleStateHandler
 
## 客户端频繁断开导致资源泄漏

1、未正确释放ByteBuf（堆外内存泄漏）
```java
ByteBuf buffer = ctx.alloc().buffer(); // 分配内存
// 未调用 buffer.release()，导致泄漏
```
2、Channel未关闭或未清理Pipeline

客户端断开时，若未调用channel.close()或未移除自定义ChannelHandler，可能导致：
- 线程池资源未释放。
- 内存中的Channel对象堆积
```java
@Override
public void channelInactive(ChannelHandlerContext ctx) {
    ctx.channel().close(); // 关闭Channel
    cleanupResources();    // 自定义清理逻辑
}
```
3、心跳机制缺失
未配置心跳检测，无法及时感知断开连接，导致资源滞留
```java
//添加心跳机制
pipeline.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));
pipeline.addLast(new HeartbeatHandler()); // 自定义心跳处理
```
4、线程池或EventLoop未正确关闭
频繁创建/销毁EventLoopGroup会导致线程泄漏
```java
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}));
```
